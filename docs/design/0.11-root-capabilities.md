# Canic 0.11: Capabilities Framework

## 1. Overview

Canic 0.11 introduces a unified Root Capability Framework that formalizes authorization for privileged root operations.

**Definition:** A Root Capability is a privileged operation that can only be executed by the root canister and is explicitly authorized via a per-variant policy function.

In 0.11, capabilities are **explicit policy-gated privileged execution**, not token-delegated authority.

Current state:

- Provisioning uses structural predicates (subnet registration and topology checks).
- Delegation issuance uses issuance policy and ECDSA authority.
- There is no shared capability abstraction.
- No replay protection exists at the root boundary.
- Authorization logic is scattered.

0.11 consolidates root authorization behind an explicit, auditable capability model while preserving existing authority domains.

## 2. Goals

### Primary Goals

- Introduce a first-class `RootCapability` abstraction.
- Unify root ingress and dispatch into a single pipeline.
- Make all privileged operations capability-gated.
- Centralize authorization logic.
- Add replay protection for mutating operations.
- Reduce duplication across provisioning and delegation flows.

### Non-Goals (0.11)

- Do not change cryptographic signing model.
- Do not allow arbitrary signing capabilities.
- Do not require delegation tokens for provisioning (future phase).
- Do not introduce cross-subnet distributed authorization.

## 3. Current Problems

| Area | Issue |
| --- | --- |
| Authorization | Predicate-based and scattered |
| Delegation issuance | Separate transport and validation stack |
| Replay protection | None |
| Rate limiting | None |
| Auditability | Capability logic not centralized |
| Duplication | Root checks duplicated across workflows |

## 4. Architectural Principles

- Single Root Ingress
- Explicit Capabilities
- Per-Variant Policy Enforcement
- Authority Domain Isolation
- Replay Safety
- Backward Compatibility

## 5. High-Level Architecture

```text
Root Endpoint
    ↓
Auth Context Extraction
    ↓
RootCapability Dispatcher
    ↓
Capability Policy Layer
    ↓
Replay / Idempotency Layer
    ↓
Capability Handler
```

Execution ordering is explicit:

1. Extract `RootContext`.
2. Decode `RootCapabilityRequest`.
3. Map request to `RootCapability`.
4. Authorize via capability policy.
5. Perform replay/idempotency checks.
6. Execute handler.
7. Persist replay entry and response cache.

## 6. Core Abstractions

### 6.1 RootCapability (Option B)

```rust
enum RootCapability {
    Provision,
    Upgrade,
    MintCycles,
    IssueDelegation,
}
```

`RootCapabilityRequest` is mapped to `RootCapability`. This keeps policy, metrics, and future delegation extensions stable even if request payloads evolve.

### 6.2 RootCapabilityRequest

```rust
enum RootCapabilityRequest {
    ProvisionCanister { config: CanisterConfig },
    UpgradeCanister { target: Principal, wasm_hash: Hash },
    MintCycles { amount: u128 },
    IssueDelegation { request: DelegationRequest },
}
```

### 6.3 RootCapabilityResponse

```rust
enum RootCapabilityResponse {
    Provisioned { canister_id: Principal },
    Upgraded,
    CyclesMinted,
    DelegationIssued { proof: DelegationProof },
}
```

### 6.4 RootContext

```rust
struct RootContext {
    caller: Principal,
    is_root_env: bool,
    subnet_id: Principal,
    now: u64,
}
```

Policy decisions must be derived only from bounded context inputs plus the request payload.

### 6.5 Capability Policy Trait

```rust
trait RootCapabilityPolicy {
    fn authorize(
        ctx: &RootContext,
        capability: RootCapability,
        req: &RootCapabilityRequest,
    ) -> Result<(), Error>;
}
```

Each capability implements its own policy logic.

This replaces:

- Endpoint guards
- Scattered root checks
- Inline issuance validation

Capabilities in 0.11 are operations, not grant objects. This release does not introduce capability storage, revocation, or delegation.

## 7. Capability Categories

### 7.1 Structural Capabilities

Derived from topology and registry:

- `root:provision_canister`
- `root:upgrade_canister`
- `root:mint_cycles`

These validate:

- Subnet registration
- Parent/child relationship
- Root context

No cryptographic delegation required (0.11 scope).

### 7.2 Cryptographic Capabilities

- `root:issue_delegation`

Validates:

- Feature flag enabled
- Caller binding to shard
- Issuance policy
- Root environment

Signing remains in:

- `DelegatedTokenOps`
- `EcdsaOps`

## 8. Replay and Idempotency (New in 0.11)

All mutating root capabilities must include:

```rust
struct RootRequestMetadata {
    request_id: [u8; 32],
    ttl_seconds: u64,
}
```

Root evaluates TTL against root local time (`ic::time()` / `IcOps::now_secs()`).

- `issued_at = now`
- `expires_at = issued_at + ttl_seconds`

Root maintains:

- `StableMap<RequestId, Expiry>`
- `StableMap<RequestId, CachedResponseDigest>`

Rules:

- Reject expired requests.
- Reject requests with `ttl_seconds > max_ttl_seconds` (configured upper bound).
- `request_id` must be high-entropy random bytes or a collision-resistant hash over canonical request bytes.
- Duplicate `request_id` with identical payload: return cached response.
- Duplicate `request_id` with different payload: reject.

This protects:

- Delegation issuance replay
- Cycle mint replay
- Provision replay

## 9. Migration Plan

### Phase 1: Introduce Dispatcher

- Add `execute_root_capability()`.
- Do not remove old endpoints.
- Map existing DTOs into capability enum.

### Phase 2: Move Provisioning Behind Dispatcher

- Convert `canic_response` handler.
- Remove duplicated root checks.
- Preserve topology constraints inside policy.

### Phase 3: Move Delegation Behind Dispatcher

- Map `DelegationRequest` to `IssueDelegation`.
- Preserve issuance policy logic.
- Preserve signing isolation.

### Phase 4: Remove Legacy Paths

- Deprecate direct RPC workflows.
- Remove duplicated guards.

## 10. Backward Compatibility

- Existing external API surface remains unchanged in 0.11.
- Existing root endpoints remain as thin adapters that map into capability dispatch.
- DTO compatibility is preserved in 0.11; no required caller-side payload changes.

## 11. Security Considerations and Threat Model

Primary security goals:

- Prevent privilege broadening across capability variants.
- Prevent replay amplification at root boundary.
- Prevent arbitrary signing access.
- Prevent cross-capability escalation.
- Preserve cryptographic domain separation.
- Preserve root-only trust authority.

### 11.1 Do Not Broaden Authorization

- `is_registered_to_subnet()` must not implicitly grant delegation issuance.
- Authorization must be explicit per capability.

### 11.2 Key Isolation

Delegation signing:

- Remains domain-separated.
- Remains ECDSA threshold-backed.
- Cannot be accessed generically.

Provisioning must never gain access to signing primitives.

### 11.3 Capability Escalation Risk

Capability dispatch must:

- Match enum variant exactly.
- Never allow generic "execute arbitrary root op".
- Avoid reflection-based dispatch.

## 12. Scalability Impact

- No material change.
- Root remains single authority.
- Provisioning remains bounded by IC management calls.
- Delegation remains bounded by ECDSA threshold cost.
- Middleware overhead is negligible.
- Replay map storage is minimal.

## 13. Benefits

- Centralized audit surface
- Cleaner mental model
- Reduced duplication
- Safer extension path
- Foundation for future delegation-based provisioning
- Replay protection added system-wide

## 14. Future Extensions (Post-0.11)

- Allow delegated tokens to authorize provisioning.
- Add capability-scoped delegation tokens for `root:mint_cycles` and `root:upgrade_canister`.
- Add rate limiting per capability.
- Add capability usage metrics.
- Add root sharding readiness.

## 15. Final Decision

0.11 introduces a unified Root Capability Framework with a separate `RootCapability` enum.

This is:

- A transport and authorization unification
- Not a cryptographic refactor
- Not a trust model rewrite

It reduces architectural entropy without destabilizing core authority domains.
