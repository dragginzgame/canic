# Canic 0.11: Unified Root Capability Framework

## 1. Overview

Canic 0.11 introduces a unified Root Capability Framework that formalizes all privileged root operations under a single dispatch, policy, and replay-controlled execution model.

A Root Capability is a privileged operation executable only by the Root canister and authorized via an explicit per-variant policy function.

Capabilities are operations, not grant objects.

0.11 unifies execution authority while preserving strict cryptographic domain isolation.

## 2. Goals

### Primary Goals

- Introduce a first-class `RootCapability` abstraction.
- Unify root ingress and dispatch into a single pipeline.
- Make all privileged operations capability-gated.
- Centralize authorization logic.
- Add replay protection for mutating operations.
- Reduce duplication across provisioning and delegation flows.
- Improve auditability and structural clarity.

### Non-Goals (0.11)

- No change to delegation cryptographic model.
- No new signing domains.
- No arbitrary signing primitives exposed.
- No distributed cross-subnet consensus.
- No role attestation or portable classification system.
- No changes to `SubnetDirectory` model.

## 3. Current Problems

| Area | Issue |
| --- | --- |
| Authorization | Predicate-based and scattered |
| Delegation issuance | Separate validation path |
| Replay protection | None |
| Rate limiting | None |
| Auditability | Logic fragmented |
| Duplication | Root checks duplicated across workflows |

The current model spreads authorization logic across endpoints and inline guards, increasing entropy and audit surface.

## 4. Architectural Principles

- Single Root Ingress
- Explicit Capability Enumeration
- Per-Variant Policy Enforcement
- Authority Domain Isolation
- Replay Safety
- Backward Compatibility

## 5. High-Level Architecture

### 5.1 Root Execution Pipeline

```text
Root Endpoint
    v
Auth Context Extraction
    v
RootCapability Dispatcher
    v
Capability Policy Layer
    v
Replay / Idempotency Layer
    v
Capability Handler
```

Execution ordering is strict:

1. Extract `RootContext`.
2. Decode `RootCapabilityRequest`.
3. Map request -> `RootCapability`.
4. Authorize via policy.
5. Perform replay checks.
6. Execute handler.
7. Persist replay state.

All privileged operations flow through this pipeline.

Dispatcher behavior is normative:

- Dispatcher **MUST** match exact `RootCapability` enum discriminant.
- Dispatcher **MUST NOT** allow dynamic dispatch by string, reflection, or generic "execute arbitrary op" handlers.

## 6. Core Abstractions

### 6.1 `RootCapability`

```rust
enum RootCapability {
    Provision,
    Upgrade,
    MintCycles,
    IssueDelegation,
}
```

Capabilities represent executable operations only.

### 6.2 `RootCapabilityRequest`

```rust
enum RootCapabilityRequest {
    ProvisionCanister { config: CanisterConfig },
    UpgradeCanister { target: Principal, wasm_hash: Hash },
    MintCycles { amount: u128 },
    IssueDelegation { request: DelegationRequest },
}
```

### 6.3 `RootCapabilityResponse`

```rust
enum RootCapabilityResponse {
    Provisioned { canister_id: Principal },
    Upgraded,
    CyclesMinted,
    DelegationIssued { proof: DelegationProof },
}
```

### 6.4 `RootContext`

```rust
struct RootContext {
    caller: Principal,
    is_root_env: bool,
    subnet_id: Principal,
    now: u64,
}
```

Policies must derive decisions only from this bounded context and request payload.

`RootContext` integrity requirements:

- `caller` **MUST** be derived from `ic::caller()`.
- `subnet_id` **MUST** be derived from system state.
- `now` **MUST** use `IcOps::now_secs()`.

### 6.5 Capability Policy Trait

```rust
trait RootCapabilityPolicy {
    fn authorize(
        ctx: &RootContext,
        capability: RootCapability,
        req: &RootCapabilityRequest,
    ) -> Result<(), Error>;
}
```

All privileged operations are routed through this trait.

This replaces:

- Endpoint-level guards
- Inline structural checks
- Scattered delegation validation logic

## 7. Capability Categories

### 7.1 Structural Capabilities

- `root:provision_canister`
- `root:upgrade_canister`
- `root:mint_cycles`

These validate:

- Subnet registration
- Parent/child relationships
- Root execution context

No cryptographic delegation is required.

### 7.2 Cryptographic Capabilities

- `root:issue_delegation`

Validates:

- Feature flag enabled
- Caller binding to shard
- Issuance policy
- Root execution environment

Signing remains in:

- `DelegatedTokenOps`
- `EcdsaOps`

No additional signing domains are introduced in 0.11.

## 8. Replay and Idempotency

All mutating root capabilities require:

```rust
struct RootRequestMetadata {
    request_id: [u8; 32],
    ttl_seconds: u64,
}
```

### 8.1 Replay Identity

A replay entry MUST be uniquely identified by:

```text
ReplayKey = hash(
    capability_variant ||
    canonical_request_payload_hash ||
    caller_principal ||
    subnet_id ||
    request_id
)
```

Where:

- `capability_variant` is the exact `RootCapability` discriminant.
- `canonical_request_payload_hash` uses deterministic canonical serialization.
- `caller_principal` is from `RootContext`.
- `subnet_id` is from `RootContext`.
- `request_id` is from `RootRequestMetadata`.

Canonical serialization requirements:

- `canonical_request_payload_hash` **MUST** use Candid canonical encoding.
- Hash input **MUST** include the capability variant discriminant.
- Hash input **MUST** exclude `RootRequestMetadata` when metadata is transported outside request payload.

This prevents:

- Cross-capability replay
- Cross-caller replay
- Cross-subnet replay
- Payload mutation under the same `request_id`

`request_id` requirements:

- `request_id` **MUST** be collision-resistant.
- `request_id` **MUST** be either 32 bytes of high-entropy randomness or a collision-resistant hash over canonical request bytes.

### 8.2 Replay Storage

Replay storage MUST contain either:

- The full serialized `RootCapabilityResponse`, or
- A deterministic recomputation contract

Implementations MUST NOT store only a digest unless the handler is strictly pure and reproducible.

A handler qualifies as deterministically recomputable only if:

- It performs no management canister calls.
- It does not mint canister IDs.
- It does not depend on external state mutation.
- It produces identical output for identical input and stable state.

Replay conflict handling requirements:

- For each tuple `(capability_variant, caller_principal, subnet_id, request_id)`, Root **MUST** bind and store the first accepted `canonical_request_payload_hash`.
- Reuse of that tuple with a different payload hash **MUST** be rejected as conflicting replay.
- Conflicting replay **MUST NOT** overwrite or mutate existing replay state.

### 8.3 Replay Expiration

Replay entries MUST expire no later than:

```text
issued_at + ttl_seconds
```

`issued_at`:

- MUST be assigned by Root at first execution.
- MUST NOT be derived from client-provided input.

Expiration enforcement requirements:

- Expiration **MUST** be checked before handler execution.
- Expired replay entries **MUST NOT** be resurrected or reinserted.

### 8.4 Replay Storage Bound and Eviction

Replay storage must remain bounded:

- Entries **MUST** be purged when expired.
- Root **MUST** enforce a bounded replay map size.
- Eviction policy **MUST** prioritize expired entries.
- Root **MUST NOT** evict unexpired entries in a way that breaks idempotent replay guarantees.

## 9. TTL and Time Semantics

### 9.1 Time Source

All TTL validation MUST use:

```rust
IcOps::now_secs()
```

Client-provided timestamps are not authoritative.

### 9.2 TTL Bounds

Root MUST enforce:

```text
0 < ttl_seconds <= MAX_ROOT_TTL_SECONDS
```

`MAX_ROOT_TTL_SECONDS` is a configuration constant.

Recommended:

```text
MAX_ROOT_TTL_SECONDS <= 300
```

## 10. Migration Plan

1. **Phase 1: Dispatcher Introduction**  
   Introduce unified `execute_root_capability()`.
2. **Phase 2: Structural Integration**  
   Move provisioning, upgrade, and cycle minting behind dispatcher.
3. **Phase 3: Delegation Integration**  
   Route delegation issuance via dispatcher.
4. **Phase 4: Remove Legacy Guards**  
   Remove scattered root checks and inline authorization logic.

## 11. Security Considerations

### 11.1 No Privilege Broadening

- Authorization must be explicit per capability.
- Structural predicates (for example, subnet membership) must not implicitly grant cryptographic privileges.

### 11.2 Domain Separation

Delegation signing remains:

- Domain-separated
- Threshold-backed
- Inaccessible from structural capability handlers

Structural capability handlers must not access signing primitives.

### 11.3 Escalation Prevention

- Exact enum matching
- No reflection dispatch
- No generic root execution endpoints
- No dynamic capability resolution

The dispatcher **MUST** reject any request that cannot be mapped to a known static enum variant.

### 11.4 Replay Safety

Replay protection prevents amplification of:

- Delegation issuance
- Provision
- Upgrade
- Cycle minting

All mutating root operations must be replay-protected.

Replay of `IssueDelegation` **MUST** return identical token material via cached response semantics; replay handling must not mint new delegation material for the same accepted request.

## 12. Scalability Impact

- No change to `SubnetDirectory` model.
- No change to delegation cost profile.
- No additional cryptographic surface.
- Replay storage bounded by TTL window.
- Middleware overhead is minimal.

0.11 is an execution-layer hardening release.

## 13. Benefits

- Centralized audit surface.
- Unified execution authority.
- Reduced duplication.
- Deterministic replay protection.
- Clear cryptographic domain separation.
- Safer extension path for future releases.

## 14. Future Extensions (Post-0.11)

- Role attestation framework.
- Portable caller classification.
- Directory reduction mechanisms.
- Capability-scoped delegation tokens.
- Rate limiting per capability.
- Root sharding support.

## 15. Final Decision

Canic 0.11 introduces:

- A unified Root Capability dispatcher.
- Deterministic replay protection.
- Centralized authorization logic.
- Hardened execution boundaries.

This is:

- An execution and authorization consolidation.
- A replay safety improvement.
- Not a cryptographic redesign.
- Not a trust model rewrite.

Root remains the single authority for privileged execution. Cryptographic delegation remains isolated and unchanged.
